<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="zhywyt" />


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="zhywyt&#39;s blog">
<meta property="og:url" content="http://hexo.zhywyt.me/page/6/index.html">
<meta property="og:site_name" content="zhywyt&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhywyt">
<meta name="twitter:card" content="summary">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="zhywyt&#39;s blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">



<link rel="stylesheet" href="/css/style.css">



    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>zhywyt&#39;s blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/encrypt/" rel="tag">encrypt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2/" rel="tag">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/" rel="tag">技术文档</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%97%E4%B8%8E%E6%95%A3%E6%96%87/" rel="tag">诗与散文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/" rel="tag">错误解决</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-Linux/ubuntu/KUbuntu安装CIscoPacketTracer" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/49793/" class="article-date">
      <time datetime="2024-05-26T15:41:00.000Z" itemprop="datePublished">2024-05-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/49793/">KUbuntu安装CIscoPacketTracer</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>

<p>注意：这是正版教程，需要你有Cisco账号。</p>
<h2 id="第一步注册账号"><a href="#第一步注册账号" class="headerlink" title="第一步注册账号"></a>第一步注册账号</h2><p>先去思科官网注册账号：<a target="_blank" rel="noopener" href="https://www.netacad.com/courses/packet-tracer">Cisco</a></p>
<p>可以先尝试这个链接，如果可以的话就跳过第二步，直接看第三步，如果链接失效了请继续第二步。<a target="_blank" rel="noopener" href="https://skillsforall.com/resources/lab-downloads">PackeTracer</a></p>
<h2 id="第二步下载PacketTracer"><a href="#第二步下载PacketTracer" class="headerlink" title="第二步下载PacketTracer"></a>第二步下载PacketTracer</h2><p>思科规定下载PacketTracer需要先免费注册任意一门课程，登陆好的页面如下：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240526152511310-1836730294_1726323545490.png" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240526152648623-1276232439_1726323545490.png" alt="image"><br>等待跳转或者点击这个Skills for all<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240526152706426-965827330_1726323545490.png" alt="image"></p>
<p>然后点击链接开始<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240526152754573-915539124_1726323545490.png" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240526152834258-1382698559_1726323545490.png" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240526152902945-865654347_1726323567021.png" alt="image"></p>
<p>进入课程后往下滚动<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240526152954382-1445776826_1726323567021.png" alt="image"></p>
<p>找到下载链接：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240526153027729-374319974_1726323567021.png" alt="image"></p>
<h2 id="第三步选择需要的版本"><a href="#第三步选择需要的版本" class="headerlink" title="第三步选择需要的版本"></a>第三步选择需要的版本</h2><p>选择对应版本并下载，安装。<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240526153223778-1604264757_1726323567021.png" alt="image"></p>
<h3 id="Ubuntu-KUbuntu-Debain"><a href="#Ubuntu-KUbuntu-Debain" class="headerlink" title="Ubuntu||KUbuntu||Debain"></a>Ubuntu||KUbuntu||Debain</h3><p>如果出现缺少<code>libgl1-mesa-glx</code>依赖，并且apt 无法直接安装的时候，那么从官方源下载deb安装即可。<a target="_blank" rel="noopener" href="https://pkgs.org/download/libgl1-mesa-glx">libgl1-mesa-glx</a><br>选择对应版本，然后找到下面的链接，下载到本地用apt安装。记得换成你对应版本的包的名字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install ./libgl1-mesa-glx_22.3.6-1+deb12u1_amd64.deb</span><br></pre></td></tr></table></figure>

<p>装好依赖后就可以正常安装CiscoPacketTracer了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Linux/">Linux</a><a class="article-category-link" href="/categories/Linux/Ubuntu/">Ubuntu</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Linux/PVE/PVE学生自用记录" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/4182/" class="article-date">
      <time datetime="2024-05-17T16:09:00.000Z" itemprop="datePublished">2024-05-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/4182/">PVE学生自用记录</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>

<h1 id="PVE记录"><a href="#PVE记录" class="headerlink" title="PVE记录"></a>PVE记录</h1><p>这篇博客主要记录自己大二阶段配置和使用PVE的过程。</p>
<h2 id="什么是PVE"><a href="#什么是PVE" class="headerlink" title="什么是PVE"></a>什么是PVE</h2><p>说到<code>PVE</code>，大家可能会想到<code>Playsers Vs Environment</code>，但是这里肯定不是指的游戏中的模式了，而是一个操作系统。</p>
<blockquote>
<p>它的全称为：<code>Proxmox VE</code>，是一个运行虚拟机和容器的平台。基于 Debian Linux 完全开源。最大的灵活性，实施了两种虚拟化技术 （1）基于内核的虚拟机 (KVM) （2）基于容器的虚拟化 (LXC)。</p>
</blockquote>
<h2 id="我为什么会接触到这个东西？"><a href="#我为什么会接触到这个东西？" class="headerlink" title="我为什么会接触到这个东西？"></a>我为什么会接触到这个东西？</h2><p>事情还要从许的这篇论文说起，那天他在朋友圈发了论文的消息，然后我便迫不及待地把代码拉下来想要跑一下，结果就有了这个朋友圈：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517151640419-111115740_1726323567021.png" alt="image"><br>是的，我这<strong>古老的笔记本</strong>无法支撑<strong>强大</strong>的Pytorch-3D编译所需要的内存，多次omm，于是我痛定思痛，想要换电脑。<br>但是我看了看我的钱包：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517152511343-1229231052_1726323590635.jpg" alt="image"><br>还是先将就着吧…………<br><strong>然后！——————</strong></p>
<h3 id="成为垃圾佬"><a href="#成为垃圾佬" class="headerlink" title="成为垃圾佬"></a>成为垃圾佬</h3><p>我在向longhao chen请教如何捡垃圾的时候，我发现了它：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517152709034-205874299_1726323590635.png" alt="image"></p>
<h4 id="分析一下："><a href="#分析一下：" class="headerlink" title="分析一下："></a>分析一下：</h4><ul>
<li>CPU : E5 2680V4*2<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517153835868-656025569_1726323590635.png" alt="image"><ul>
<li><strong>一颗100 ，两颗200</strong></li>
</ul>
</li>
<li>主板：Z10PA-D8<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517153819905-383790457_1726323590635.png" alt="image"><ul>
<li><strong>600左右</strong></li>
</ul>
</li>
<li>内存条 ： 3200 * 16g *2条<ul>
<li><strong>一条320 ，两条640</strong></li>
</ul>
</li>
<li>电源<ul>
<li><strong>240左右</strong></li>
</ul>
</li>
<li>机箱<ul>
<li><strong>50</strong></li>
</ul>
</li>
<li>总计<ul>
<li><strong>1730</strong></li>
</ul>
</li>
<li>到手<ul>
<li><strong>1030</strong></li>
</ul>
</li>
</ul>
<p>要求不高，只要能点亮，不少配件就赚麻了。</p>
<h4 id="激情下单购买配件"><a href="#激情下单购买配件" class="headerlink" title="激情下单购买配件"></a>激情下单购买配件</h4><p>128G nvme 固态当缓存（但最后因为速度太慢放弃了）<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517154046528-508019228_1726323590635.jpg" alt="image"><br>5*500G sata机械盘组RAID5阵列</p>
<blockquote>
<p>Raid5：至少需要3块硬盘<br>raid5优势：以上优势，raid5兼顾。任意N-1快硬盘都有完整的数据。<br>缺点：只允许单盘故障，一盘出现故障得尽快处理。有盘坏情况下，raid5 IO&#x2F;CPU性能狂跌，此时性能烂到无以复加。<br>建议：盘不多，对数据安全性和性能提示都有要求，raid5是个不错选择</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517154050308-925812108_1726323611610.jpg" alt="image"></p>
<h3 id="装机"><a href="#装机" class="headerlink" title="装机"></a>装机</h3><p>配件完好，机箱像新的，用户手册非常详细。<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517154518395-927108097_1726323611610.png" alt="image"><br>外挂机械测试是否可正常组阵列。这里组阵列也是用到了PVE的软组，非常的方便。<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517154528816-1594179286_1726323611610.png" alt="image"><br>Bios版本<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517154621448-79517483_1726323611610.png" alt="image"><br>CPU正确<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517154631144-1816898344_1726323611611.png" alt="image"><br>操作系统安装<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517154658294-69713113_1726323620532.png" alt="image"><br>意外之喜：BMC<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517154856657-2015804610_1726323620532.png" alt="image"></p>
<h3 id="PVE"><a href="#PVE" class="headerlink" title="PVE"></a>PVE</h3><p>再通过zerotier进行路由，直接远程连接容器，垃圾佬也是用上自己的服务器了。<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517155046664-51199699_1726323620532.png" alt="image"></p>
<h4 id="zerotier-路由设置"><a href="#zerotier-路由设置" class="headerlink" title="zerotier 路由设置"></a>zerotier 路由设置</h4><p><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517155412142-2016686325_1726323620532.png" alt="image"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>longhao chen给我的建议是：<strong>不要在节点上拉屎，工作全部在容器中进行。</strong><br>节点就是我的PVE服务器（因为PVE服务器可以存在多个一起组网），然后容器就是运行在PVE上的容器。<br>于是我当即立下创建了我人生中的第一个<strong>CT容器</strong>，取名为<strong>Main</strong>。开始了我垃圾佬的一生。<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517163353295-2090178253_1726323620532.png" alt="image"></p>
<h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>PVE除了可以创建容器以外还可以创建虚拟机！而我刚好有有一些只能在windows上运行的软件，于是便可以通过远程桌面直接控制windows：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240517164138857-1798400883_1726323646907.png" alt="image"></p>
<h3 id="Ubuntu远程桌面"><a href="#Ubuntu远程桌面" class="headerlink" title="Ubuntu远程桌面"></a>Ubuntu远程桌面</h3><p>由于图形学的<strong>显示</strong>+<strong>计算</strong>需要，使用ubuntu的远程桌面貌似是最好的解决办法了，于是我找了一些方法，最后找到了这位大佬的帖子：<br><a target="_blank" rel="noopener" href="https://www.right.com.cn/forum/thread-8227639-1-1.html">PVE下安装LXC创建桌面环境</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Linux/">Linux</a><a class="article-category-link" href="/categories/Linux/PVE/">PVE</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-算法基础/第？课——基于矩阵快速幂的递推解法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/62236/" class="article-date">
      <time datetime="2024-05-04T15:05:00.000Z" itemprop="datePublished">2024-05-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/62236/">第？课——基于矩阵快速幂的递推解法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>

<p>第？课——基于矩阵快速幂的递推解法<br>由于中间的数论部分我自己学的很差，没有办法写出清晰的博客来，所以这里跳过了数论部分的博客，来到矩阵快速幂。</p>
<h1 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h1><p>递推是一个非常常用的工具。比如经典的斐波那契数列：</p>
<p>\[f(x)&#x3D; \left\{ \begin{array}{**lr**} 1 &amp;, 0\leq x\leq 1 \\ f(x-1)+f(x-2)&amp;, 2 \leq x \\ \end{array} \right. \]</p>
<p>很明显，\(f(n)\)依赖于\(f(n-1)\)和\(f(n-2)\)，所以我们需要先计算\(f(n-1)f(n-2)\)才能计算\(f(n)\)。</p>
<hr>
<p>假设我们现在需要求<strong>f(1e9+7)</strong>，你很快发现了，这个数字非常大。所以我们要求只需要结果对\(MOD\)取模就好了，而\(MOD&#x3D;1e9+7\)。问题是：我们的迭代算法是\(O(n)\)的。那如何快速的求解这样一个递推问题呢？</p>
<h1 id="矩阵与递推的联系"><a href="#矩阵与递推的联系" class="headerlink" title="矩阵与递推的联系"></a>矩阵与递推的联系</h1><p>让我们站在巨人的肩膀上来看这个递推问题的第二项以及之后：</p>
<p>\[\begin{pmatrix}f(n)\\? \\\end{pmatrix}&#x3D; \begin{pmatrix}1&amp;1\\?&amp;?\\\end{pmatrix}\dot\\ \begin{pmatrix}f(n-1)\\f(n-2)\end{pmatrix} \]</p>
<p>数学家们把这个问题用矩阵的形式表现了出来。但是矩阵上还有一行是空的。打个比方，我们在求\(f(2)\)的时候，矩阵可以写成：</p>
<p>\[\begin{pmatrix}f(2)\\? \\\end{pmatrix}&#x3D; \begin{pmatrix}1&amp;1\\?&amp;?\\\end{pmatrix}\dot\\ \begin{pmatrix}f(1)\\f(0)\end{pmatrix} \]</p>
<p>那如果我们需要继续计算\(f(3)\)呢？</p>
<p>\[\begin{pmatrix}f(3)\\? \\\end{pmatrix}&#x3D; \begin{pmatrix}1&amp;1\\?&amp;?\\\end{pmatrix}\dot\\ \begin{pmatrix}f(2)\\f(1)\end{pmatrix} \]</p>
<p>我们需要知道</p>
<p>\[\begin{pmatrix}f(2)\\f(1)\end{pmatrix} \]</p>
<p>可是\(f(2)f(1)\)哪里来呢？不妨把我们的通项改写一下，在计算\(f(n)\)的同时顺带计算\(f(n-1)\)？</p>
<p>\[\begin{pmatrix}f(n)\\f(n-1) \\\end{pmatrix}&#x3D; \begin{pmatrix}1&amp;1\\1&amp;0\\\end{pmatrix}\dot\\ \begin{pmatrix}f(n-1)\\f(n-2)\end{pmatrix} \]</p>
<p>！！wow，我们得到了一个强大的新递推式子。这时候有人要不乐意了，这不是复杂化了么，我们本来只要两个数加一加，现在还要算一个2$\times$4的矩阵乘法？<strong>可是，我们的矩阵是常数。</strong> 再稍微改写一下这个式子：</p>
<p>\[\begin{pmatrix}f(n)\\f(n-1) \\\end{pmatrix}&#x3D; \begin{pmatrix}1&amp;1\\1&amp;0\\\end{pmatrix}^{n-1} \\ \dot\\ \begin{pmatrix}f(1)\\f(0)\end{pmatrix} \]</p>
<p>相信你看到这里已经顿悟了，因为这个矩阵的高次幂我们可以大做文章！</p>
<h1 id="快速幂与矩阵快速幂"><a href="#快速幂与矩阵快速幂" class="headerlink" title="快速幂与矩阵快速幂"></a>快速幂与矩阵快速幂</h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>快速幂很简单，这里直接给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(x&amp;<span class="number">1</span>) a=a*b;</span><br><span class="line">		b=b*b;</span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速幂原理给一个友情链接：<br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/Renyi-Fan/p/8142674.html" title="快速幂总结">快速幂总结</a></p>
<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>先放一个市面上常见的<strong>通用</strong>矩乘：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=n; k++) &#123;</span><br><span class="line">			tmp.mat[i][j]+=(a.mat[i][k]%mod*b.mat[k][j]%mod)%mod;	\\拖慢速度</span><br><span class="line">			tmp.mat[i][j]%=mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个矩阵乘非常符合人的想法，但是有一个点让它比较慢，我们矩阵快速幂只需要进行<strong>幂次乘法</strong>，可以做一些优化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=n; k++) &#123;</span><br><span class="line">			tmp.mat[i][k]+=(a.mat[i][j]%mod*b.mat[j][k]%mod)%mod;</span><br><span class="line">			tmp.mat[i][k]%=mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看出不一样的地方了吗？唯一的区别就在下标处。把k放在第一维会大大增加寻址的计算量，所以需要把k放在第二维上就能减少非常多的计算量。<del>其实矩阵小的时候也没什么区别</del></p>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>其实和普通快速幂没有多大区别，只需要重载一个乘法运算符就好了。这里给一份结构体加快速幂的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = (<span class="type">int</span>)<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyMat</span>&#123;</span><br><span class="line">    <span class="built_in">MyMat</span>(<span class="type">int</span> n_=<span class="number">24</span>,<span class="type">int</span> m_=<span class="number">24</span>):<span class="built_in">n</span>(n_),<span class="built_in">m</span>(m_)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="built_in">sizeof</span>(mat));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mat[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">friend</span> MyMat <span class="keyword">operator</span>*(<span class="type">const</span> MyMat&amp;a,<span class="type">const</span> MyMat&amp;b)&#123;</span><br><span class="line">        MyMat tmp;</span><br><span class="line">        <span class="keyword">if</span>(a.m!=b.n)<span class="keyword">throw</span>(<span class="string">&quot;Matrix size mismatch&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=a.n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=b.m; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=a.m; k++) &#123;</span><br><span class="line">                    tmp.mat[i][j]+=(a.mat[i][k]%mod*b.mat[k][j]%mod)%mod;</span><br><span class="line">                    tmp.mat[i][j]%=mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.n = a.n,tmp.m=b.m;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp;is,MyMat&amp; M)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M.n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=M.m;j++)&#123;</span><br><span class="line">                is&gt;&gt;M.mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;os,<span class="type">const</span> MyMat&amp; M)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M.n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=M.m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j!=<span class="number">1</span>)os&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                os&lt;&lt;M.mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            os&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyMat <span class="title">quickpow</span><span class="params">(MyMat a,MyMat b,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(x&amp;<span class="number">1</span>) a=b*a;</span><br><span class="line">		b=b*b;</span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">MyMat <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span>,<span class="title">b</span><span class="params">(<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">auto</span> ans = a*b;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a:\n&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;*\nb:\n&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;=\n&quot;</span>&lt;&lt;ans;</span><br><span class="line">    ans = <span class="built_in">quickpow</span>(a,ans,<span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a*ans^5=\n&quot;</span>&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感兴趣的可以当一个参考。下面是本地运行测试输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">g++ -o <span class="built_in">test</span> test.cpp</span><br><span class="line">./test</span><br><span class="line">1 2 1 2 1 2 </span><br><span class="line">1 2 3 1 2 3</span><br><span class="line">a:</span><br><span class="line">1 2 1</span><br><span class="line">2 1 2</span><br><span class="line">*</span><br><span class="line">b:</span><br><span class="line">1 2</span><br><span class="line">3 1</span><br><span class="line">2 3</span><br><span class="line">=</span><br><span class="line">9 7</span><br><span class="line">9 11</span><br><span class="line">a*ans^5=</span><br><span class="line">2480048 2480080 2480048</span><br><span class="line">3188656 3188624 3188656</span><br></pre></td></tr></table></figure>

<h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>让我们回到经典的斐波那契数列，写出这个矩阵递推式后，加上矩阵快速幂</p>
<p>\[\begin{pmatrix}f(n)\\f(n-1) \\\end{pmatrix}&#x3D; \begin{pmatrix}1&amp;1\\1&amp;0\\\end{pmatrix}^{n-1} \\ \dot\\ \begin{pmatrix}f(1)\\f(0)\end{pmatrix} \]</p>
<p>我们就能快速地写出斐波那契数列的代码了，和上面不同的地方只有<code>quickpow</code>函数的x改为了<code>long long</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyMat <span class="title">quickpow</span><span class="params">(MyMat a,MyMat b,<span class="type">long</span> <span class="type">long</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(x&amp;<span class="number">1</span>) a=b*a;</span><br><span class="line">		b=b*b;</span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        MyMat <span class="built_in">A</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        A.mat[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        A.mat[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        A.mat[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="function">MyMat <span class="title">x</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        x.mat[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        x.mat[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> ans = <span class="built_in">quickpow</span>(x,A,n);</span><br><span class="line">        cout&lt;&lt;ans.mat[<span class="number">1</span>][<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-Simple-Math-Problem"><a href="#A-Simple-Math-Problem" class="headerlink" title="A Simple Math Problem"></a>A Simple Math Problem</h2><p><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240504143926600-1236293094_1726323646907.png" alt="image"><br><strong>重点：</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240504144123585-1762427676_1726323646907.png" alt="image"><br>这个矩阵我就不写了，自己动手尝试一下吧～</p>
<h2 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h2><p><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240504144324258-345631460_1726323646907.png" alt="image"><br><strong>重点：</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240504144348716-607499872_1726323646907.png" alt="image"></p>
<p>\[\left\{ \begin{array}{**lr**} f(n) &#x3D; f(n-1)+2f(n-2)+n^3 \\n^3 &#x3D; (n-1)^3-3n^3-3n-1\\n^2 &#x3D; (n-1)^2+2n-1\\n &#x3D; n-1 \end{array} \right. \]</p>
<p>\[\begin{pmatrix}f(n)\\ f(n-1) \\ n^3\\ n^2\\ n\\\ 1 \end{pmatrix}&#x3D; \begin{pmatrix}1&amp;2&amp;1&amp;3&amp;3&amp;1\\1&amp;0&amp;0&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;3&amp;3&amp;1\\0&amp;0&amp;0&amp;1&amp;2&amp;1\\0&amp;0&amp;0&amp;0&amp;1&amp;1\\0&amp;0&amp;0&amp;0&amp;0&amp;1 \end{pmatrix}\\ \dot\\ \begin{pmatrix}f(n-1)\\f(n-2)\\(n-1)^3\\(n-1)^2\\n-1\\1\end{pmatrix} \]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AC代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = (<span class="type">int</span>)<span class="number">123456789</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyMat</span>&#123;</span><br><span class="line">    <span class="built_in">MyMat</span>(<span class="type">int</span> n_=<span class="number">24</span>,<span class="type">int</span> m_=<span class="number">24</span>):<span class="built_in">n</span>(n_),<span class="built_in">m</span>(m_)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="built_in">sizeof</span>(mat));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mat[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">friend</span> MyMat <span class="keyword">operator</span>*(<span class="type">const</span> MyMat&amp;a,<span class="type">const</span> MyMat&amp;b)&#123;</span><br><span class="line">        MyMat tmp;</span><br><span class="line">        <span class="keyword">if</span>(a.m!=b.n)<span class="keyword">throw</span>(<span class="string">&quot;Matrix size mismatch&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=a.n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=b.m; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=a.m; k++) &#123;</span><br><span class="line">                    tmp.mat[i][j]+=<span class="number">1ll</span>*a.mat[i][k]*b.mat[k][j]%mod;		<span class="comment">//1ll防止爆int</span></span><br><span class="line">                    tmp.mat[i][j]%=mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.n = a.n,tmp.m=b.m;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp;is,MyMat&amp; M)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M.n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=M.m;j++)&#123;</span><br><span class="line">                is&gt;&gt;M.mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;os,<span class="type">const</span> MyMat&amp; M)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M.n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=M.m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j!=<span class="number">1</span>)os&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                os&lt;&lt;M.mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            os&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyMat <span class="title">quickpow</span><span class="params">(MyMat a,MyMat b,<span class="type">long</span> <span class="type">long</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(x&amp;<span class="number">1</span>) a=b*a;</span><br><span class="line">		b=b*b;</span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">instr</span><span class="params">(<span class="string">&quot;1 2 1 3 3 1  1 0 0 0 0 0  0 0 1 3 3 1  0 0 0 1 2 1  0 0 0 0 1 1  0 0 0 0 0 1  2 1 8 4 2 1&quot;</span>)</span></span>;</span><br><span class="line">    std::stringstream is;</span><br><span class="line">    is&lt;&lt;instr;</span><br><span class="line">    <span class="function">MyMat <span class="title">A</span><span class="params">(<span class="number">6</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">MyMat <span class="title">x</span><span class="params">(<span class="number">6</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    is&gt;&gt;A&gt;&gt;x;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;=<span class="number">2</span>)cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> ans = <span class="built_in">quickpow</span>(x,A,m<span class="number">-2</span>);</span><br><span class="line">            cout&lt;&lt;(ans.mat[<span class="number">1</span>][<span class="number">1</span>])%mod&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Linux/ubuntu/ubuntu无法进入桌面的一种情况" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/7287/" class="article-date">
      <time datetime="2024-04-23T16:21:00.000Z" itemprop="datePublished">2024-04-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/7287/">ubuntu无法进入桌面的一种情况</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>系统环境：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240423163225383-1782844975_1726323663548.png" alt="image"></p>
<ul>
<li>无法进入桌面</li>
<li>可以进入锁屏</li>
<li>输入密码后黑屏，并返回锁屏</li>
<li>tty能进入<code>startx</code></li>
<li><code>startx</code>中部分软件无法打开<br>无法进入桌面最直接的错误，非常严重不可原谅。用户登陆输入密码，黑屏，然后回到用户登陆。</li>
</ul>
<h2 id="误导我的一个报错："><a href="#误导我的一个报错：" class="headerlink" title="误导我的一个报错："></a>误导我的一个报错：</h2><p><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240423162206763-1640149187_1726323663548.png" alt="image"><br>起初我认为是xdroid-server出毛病了，但是后来发现它无法启动，于是尝试使用<code>startx</code>来寻找错误。</p>
<h2 id="tty如何进入"><a href="#tty如何进入" class="headerlink" title="tty如何进入"></a>tty如何进入</h2><p>在锁屏页面使用<code>Ctrl+Alt+F4</code>，即可进入<code>tty</code>。<br>进入后输入用户名和用户密码。</p>
<h2 id="进入startx进行debug"><a href="#进入startx进行debug" class="headerlink" title="进入startx进行debug"></a>进入startx进行debug</h2><p>登陆好后使用<code>startx</code>进入。<br>后续操作使用<code>tty</code>执行<code>startx</code>展现。</p>
<h2 id="大量的-desktop无法打开"><a href="#大量的-desktop无法打开" class="headerlink" title="大量的.desktop无法打开"></a>大量的.desktop无法打开</h2><p>执行<code>code</code>竟然出现<code>Node.js</code>的报错</p>
<p><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240423161316305-2104047575_1726323663548.png" alt="image"></p>
<p>打开<code>code</code>可以看到顶部的解释器选择，如果直接指定解释器，发现能够打开VSCode，说明不是可执行文件的错误。</p>
<p><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240423161326206-1860745500_1726323663548.png" alt="image"></p>
<p>指定解释器：</p>
<p><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240423161343885-1891381834_1726323663548.png" alt="image"></p>
<p>如果去掉<code>code</code>中的指定解释器行：</p>
<p><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240423161351037-1625310902_1726323679699.png" alt="image"></p>
<p>成功打开：</p>
<p><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240423161357706-1589883165_1726323679699.png" alt="image"></p>
<h2 id="发现了Node-js"><a href="#发现了Node-js" class="headerlink" title="发现了Node.js"></a>发现了Node.js</h2><p>观察到VScode的解释器是&#x2F;usr&#x2F;bin&#x2F;env sh</p>
<p>为什么不是&#x2F;bin&#x2F;sh或者&#x2F;usr&#x2F;bin&#x2F;sh呢？</p>
<p>于是我尝试运行了&#x2F;usr&#x2F;bin&#x2F;env发现！：</p>
<p><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240423161402829-1386755668_1726323679699.png" alt="image"></p>
<p>我天呢？这是什么道理？</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>综上所述，我认为是&#x2F;bin&#x2F;env和&#x2F;usr&#x2F;bin&#x2F;env被NodeJs覆写了，于是我决定删除&#x2F;bin&#x2F;env，然后重装<code>coreutils</code>问题解决：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /bin/env</span><br><span class="line"><span class="built_in">sudo</span> apt reinstall coreutils</span><br></pre></td></tr></table></figure>

<p>另外因为安装了<code>gnome-tweaks</code>和原来的某些东西有冲突，卸载后恢复原状：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt remove gnome-tweaks </span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一个非常奇怪的问题，因为我的<code>/bin/env</code>被<code>Node.js</code>覆写了，导致大量依赖于<code>/bin/env</code>寻找环境的批处理无法运行，这才导致了桌面无法打开。<br>debug期间我干了：</p>
<h3 id="重装显卡驱动"><a href="#重装显卡驱动" class="headerlink" title="重装显卡驱动"></a>重装显卡驱动</h3><h3 id="卸载nodejs"><a href="#卸载nodejs" class="headerlink" title="卸载nodejs"></a>卸载nodejs</h3><h3 id="删除所有与nodejs有关的文件"><a href="#删除所有与nodejs有关的文件" class="headerlink" title="删除所有与nodejs有关的文件"></a>删除所有与nodejs有关的文件</h3><h3 id="重装gnome"><a href="#重装gnome" class="headerlink" title="重装gnome"></a>重装gnome</h3><h3 id="切换内核"><a href="#切换内核" class="headerlink" title="切换内核"></a>切换内核</h3><h3 id="修改用户权限"><a href="#修改用户权限" class="headerlink" title="修改用户权限"></a>修改用户权限</h3><h3 id="修改profile、-bashrc、-etc-environment……"><a href="#修改profile、-bashrc、-etc-environment……" class="headerlink" title="修改profile、~&#x2F;.bashrc、&#x2F;etc&#x2F;environment……"></a>修改profile、~&#x2F;.bashrc、&#x2F;etc&#x2F;environment……</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Linux/">Linux</a><a class="article-category-link" href="/categories/Linux/Ubuntu/">Ubuntu</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-算法基础/第三课——最短路" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/61355/" class="article-date">
      <time datetime="2024-04-05T15:14:00.000Z" itemprop="datePublished">2024-04-05</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/61355/">第三课——最短路</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>

<h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><p>最短路的算法是学了非常多次的一个算法了，但是这次学到的算是更加全面的一次。以前从数据结构中学到的两种最短路的算法，<strong>Dijkstra</strong>和<strong>Floyd</strong>。这两个算法在这篇文章中也会提到，最为最基础的两种最短路算法，后续的算法也都是在他们的基础上展开的。文章的最后，还提到了最短路的一个变种（故切算是？）<strong>差分约束</strong>。</p>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p><strong>Dijkstra</strong>的想法其实有一种局部搜索的感觉，它做的事情是：“按照中转次数递增的顺序找最短路。”。和人的思想很像，看下面这张图：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240402154048155-648329158_1726323679699.png" alt="image"><br>假如我从\(C_{1}\)出发，那么人会先看到自己一步能走到的地方：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240402154458113-1501790980_1726323704365.png" alt="image"><br>不管它最终要到哪里，都应该先走到最近的地方，也就是\(C_{3}\)，那么\(C_{1}\)到\(C_{3}\)的最短路就找到了，也就是\(edge_{1,3}\)。然后我们把\(C_{3}\)一步能到的点加入视线中：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240402154742845-679931193_1726323693763.png" alt="image"><br>这里我们通过中转可以到达\(C_{4}\)，但是发现从\(C_{3}\)中转再到\(C_{4}\)的距离大于到\(C_{2}\)的距离。所以我们把\(C_{2}\)加入候选集。同样的，\(C_{2}\)能到的点也要加入视线。<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240402155028854-2035783510_1726323693763.png" alt="image"><br>后续的操作我就用图片展示了：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240402155208065-1326914405_1726323693763.png" alt="image"><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240402155651840-1076251832_1726323693763.png" alt="image"><br>这里有个点，提一下。可以发现当前\(edge{1,2,4}\)是比\(edge{1,3,4,6}\)短的，但是因为\(C_{4}\)已经存在最短路了，而且那条路一定比新的路更短，所以不需要考虑在候选集中的点的最短路了。接下来应该更新\(C_{6}\)：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240402155909612-657872432_1726323693763.png" alt="image"><br>到这里，从起点到所有点的最短路就都算出来了。这是人脑的求路过程，而<strong>Dijkstra</strong>也是非常相似的做法，这里给出代码描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数据定义*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 101  			<span class="comment">//节点个数、</span></span></span><br><span class="line"><span class="comment">//inf 不能赋值为0x7fffffff，执行inf+inf时会溢出。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3FFFFFFF</span></span><br><span class="line"><span class="type">int</span> map[N][N];</span><br><span class="line"><span class="type">int</span> via[N];</span><br><span class="line"><span class="type">int</span> dis[N];				<span class="comment">//起点到某一个点的最短距离</span></span><br><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	via[i] = <span class="number">1</span>;</span><br><span class="line">	dis[i] = inf;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)map[i][j]=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*算法部分*/</span></span><br><span class="line"><span class="type">int</span> start = <span class="number">1</span>, target = n;</span><br><span class="line"><span class="type">int</span> now = start;</span><br><span class="line">dis[start]=<span class="number">0</span>;</span><br><span class="line">via[start]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(now!=target)&#123;</span><br><span class="line">	<span class="type">int</span> MIN = inf,next=now;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;		<span class="comment">//注意这里，下面要讲</span></span><br><span class="line">		<span class="keyword">if</span>(map[now][i]!=inf)	<span class="comment">//没有这一句会上溢出，因为涉及了0x7FFFFFF+0x7FFFFFFF</span></span><br><span class="line">			dis[i] = <span class="built_in">min</span>(dis[i],map[now][i]+dis[now]);</span><br><span class="line">		<span class="keyword">if</span>(via[i]&amp;&amp;dis[i]&lt;MIN)&#123;</span><br><span class="line">			next = i;</span><br><span class="line">			MIN = dis[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(MIN == inf)<span class="keyword">break</span>;</span><br><span class="line">	now = next;</span><br><span class="line">	via[now]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dis[target]==inf)<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[target]);</span><br></pre></td></tr></table></figure>

<p><strong>Dijkstra</strong>有一个非常明显的问题，通过比较与人脑的算法就能看出来，<strong>Dijkstra</strong>算法在判断下一个要进候选集的点的时候，需要遍历所有的点，这也使得复杂度来到了\(O(n^2)\)。想像一下，如果一个图比较稀疏，比如城市道路，可能有上千个十字路口，但是每个十字路口只有四条边左右。这个时候，如果也需要搜索每一个点的话，就会显得非常的多余。下面就是一个对比：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240402161453232-665487656_1726323704365.png" alt="image"><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240402161528088-345057567_1726323704365.png" alt="image"><br>所以我可以使用链表来存储点的邻边，这样就能非常方便的访问各个点边了，但是有人会说了<del>链表太慢了，我才不用</del>，于是我们用数组来模拟链表——<strong>链式前向星</strong>。</p>
<h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><p>这是一种数据结构，它用数组来存储邻接表。<br>邻接表我就不介绍了，这里直接介绍<strong>链式前向星</strong>：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240402195635977-707252819_1726323704365.png" alt="image"></p>
<p>图上模拟的就是内存中的数据存储。这个数据结构主要由两个表组成，第一个是<strong>head表</strong>，其中<code>from</code>作为下标而存在，实际上它只有一个值，就是<code>next</code>，表示从该下标对应的顶点出发的点存储位置。比如，我们上面提到的图中，\(C_{1}\)点有两条出边，分别是\(C_{2}，C_{3}\)，那么我们可以通过<code>head[1].next</code>找到<strong>edge表</strong>中对应的边。再看<strong>edge表</strong>，首先是一个下标<code>index</code>实际并不存储，然后是<code>to</code>它是边的另一个顶点的编号，再是<code>value</code>也就是该边的权值，最后是<code>next</code>它和<strong>head表</strong>中的<code>next</code>有着相同的属性，他们都是<strong>edge表</strong>的下标。通过<code>edge[1].next</code>我们可以找到\(C_{1}\)的下一条边。也就是\(edge_{1,3}\)。学过链表的同学想必已经理解了。没有学过的同学可以再思考一下。<br>最后是这个数据结构的一个基础实现，主要是一个插入操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005		<span class="comment">//顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 200005		<span class="comment">//边数</span></span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> head[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> to,dis,next;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_dege</span><span class="params">(<span class="type">long</span> <span class="type">long</span> from,<span class="type">long</span> <span class="type">long</span> to,<span class="type">long</span> <span class="type">long</span> value)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to = to;</span><br><span class="line">    edge[cnt].dis = value;</span><br><span class="line">    edge[cnt].next = head[from];</span><br><span class="line">    head[from] = cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆优化的Dijkstra"><a href="#堆优化的Dijkstra" class="headerlink" title="堆优化的Dijkstra"></a>堆优化的Dijkstra</h2><p>学会了<strong>链式前向星</strong>，我们来尝试一下思考如何用在<strong>Dijkstra</strong>上吧。<br>我们需要优化的点是：<strong>Dijkstra每次更新候选集的时候，需要遍历所有的点。</strong></p>
<h3 id="优先队列的设计"><a href="#优先队列的设计" class="headerlink" title="优先队列的设计"></a>优先队列的设计</h3><p>那么我们可以使用一个<strong>优先队列</strong>来维护我们当前访问到的点，并且排序的依据应该是<strong>该点到起始点的当前最短路长度</strong>。回到我们的人工计算最短路上来：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240402154458113-1501790980_1726323704365.png" alt="image"><br>我们起初候选集里只有起点，但是我们能访问到的点有两个，<strong>并且这两个点都不在候选集里面</strong>。于是我们将他们<strong>连同他们的当前最短路</strong>加入优先队列中，下次从队列中取出最短的最短路就可以了。<br>我们可以设计一个放入队列中的数据包like this，其中，重载了小于运算符是为了让它在优先队列中能自动排序。因为我们需要构造最小堆，所以应该重载为<code>a.dis&lt;dis</code>。因为优先队列是默认最大堆，而默认使用小于符号排序，所以我们需要重载反向的小于符号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> id,dis;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node&amp;a)<span class="type">const</span>&#123;<span class="keyword">return</span> a.dis&lt;dis;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="点的重复"><a href="#点的重复" class="headerlink" title="点的重复"></a>点的重复</h3><p>点的重复指的是一个点可能多次入队列，但是只要我们取出了某一个点，就能判断：<strong>后续出现的该点的距离一定比当前大，也就是后续的点都是多余的部分。</strong> 所以我们维护一个数组来标记顶点是否出队列，一旦出队列，就在后续的计算中不再接受该顶点。看代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(node&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node a = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> now = a.id;</span><br><span class="line">        <span class="keyword">if</span>(vis[now])<span class="keyword">continue</span>;		<span class="comment">//一旦出队列，就在后续的计算中不再接受该顶点</span></span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = head[now];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> j = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[now]+edge[i].dis&lt;dis[j])&#123;</span><br><span class="line">                dis[j]=dis[now]+edge[i].dis;</span><br><span class="line">                q.<span class="built_in">push</span>(node&#123;j,dis[j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个完整的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3FFFFFFFFFFFFFFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 200005</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cnt,head[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,s;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[N],vis[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> to,dis,next;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_dege</span><span class="params">(<span class="type">long</span> <span class="type">long</span> from,<span class="type">long</span> <span class="type">long</span> to,<span class="type">long</span> <span class="type">long</span> value)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to = to;</span><br><span class="line">    edge[cnt].dis = value;</span><br><span class="line">    edge[cnt].next = head[from];</span><br><span class="line">    head[from] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> id,dis;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node&amp;a)<span class="type">const</span>&#123;<span class="keyword">return</span> a.dis&lt;dis;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(node&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node a = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> now = a.id;</span><br><span class="line">        <span class="keyword">if</span>(vis[now])<span class="keyword">continue</span>;</span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = head[now];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> j = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[now]+edge[i].dis&lt;dis[j])&#123;</span><br><span class="line">                dis[j]=dis[now]+edge[i].dis;</span><br><span class="line">                q.<span class="built_in">push</span>(node&#123;j,dis[j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;s)!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)*N);</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)*N);</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)*N);</span><br><span class="line">        <span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="built_in">sizeof</span>(Edge)*M);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> u,v,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            <span class="built_in">add_dege</span>(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Dijkstra</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            i==<span class="number">1</span>?<span class="number">1</span>:<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><p>相比<strong>Dijkstra</strong>，<strong>Floyd</strong>真是再简单不过了，它使用的是一个非常清晰的动态规划的思想，使用三次循环直接算出任意两点之间的最短路。这里先给出核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">			 e[i][j] = <span class="built_in">min</span>(e[i][j],e[i][k]+e[k][j]);</span><br></pre></td></tr></table></figure>

<p>状态转移方程的含义就是从<code>i</code>点出发，借助<code>k</code>点到达<code>j</code>点是否会更快。</p>
<h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><p><strong>Bellman-Ford</strong>优化了<strong>Floyd</strong>固定\(O(N^3)\)的时间复杂度，继承了<code>Floyd</code>的动态规划的思想，得到了这么一个可以控制最大中转次数的路径算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">-1</span>;k++)&#123;				<span class="comment">//控制中转的次数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;				<span class="comment">//遍历所有的边</span></span><br><span class="line">		  <span class="keyword">if</span>(dis[v[i]]&gt;disp[u[i]]+w[i])&#123;</span><br><span class="line">			dis[v[i]]=dis[u[i]]+w[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>v[i]</code>是第<code>i</code>条边的入点，<code>u[i]</code>是第<code>i</code>条边的出点，<code>w[i]</code>是第<code>i</code>条边的权值。它的单点时间复杂度是\(O(N\times M )\)，可能会比<strong>Dijkstra</strong>还慢，但是优点是算法简单，而且可以解负权边。</p>
<p>如何解负权边呢？</p>
<p><strong>Dijkstra</strong>不能解负权边的原因是遇到负环的时候会出现死循环，而<strong>Bellman-Ford</strong>可以控制中转次数。如果一条路的中转次数超过了<code>n-1</code>次那说明它一定经过了负权环。也就是说，只要我们再进行一次内部循环，如果<code>dis</code>数组发生了改变，说明存在负权环。下面是判断负权环的代码<del>其实很简单</del></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">-1</span>;k++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[v[i]]&gt;disp[u[i]]+w[i])&#123;</span><br><span class="line">            dis[v[i]]=dis[u[i]]+w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[v[i]]&gt;disp[u[i]]+w[i])&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;存在负权环\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>SPFA全称<strong>shortest path fast algorithm</strong>，也就是快速最短路算法，非常正宗的中国式英语。<br>SPFA尝试解决<strong>Bellman-Ford</strong>每次都需要遍历<code>n-1</code>条边的问题，用队列维护需要修改的点。具体做法如下：<br><strong>首先把起点放入队列，然后松弛相邻的所有点，如果松弛成功而且点不在队列中，则把点加入队列。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//spfa参考代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(u); vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>(); vis[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=first[x];i!=<span class="number">-1</span>;i=next[i])&#123;</span><br><span class="line">            <span class="type">int</span> y = v[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+w[i]&lt;dis[y])&#123;</span><br><span class="line">                dis[y]=dis[x]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[y])vis[y]=<span class="number">1</span>,q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，spfa也能够判断负环的存在，但是需要我们记录每次使用的点，只要某一个节点我们使用的次数超过了<code>n-1</code>次，那么也能说明存在负环。这里就不给代码了。</p>
<h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><p>差分约束是最短路的一种问题表达形式，本质上是同一个问题。<br>2024-04-05 15:13:11 星期五<strong>后续再更新差分约束</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-算法基础/第二课——线段树" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/14027/" class="article-date">
      <time datetime="2024-03-23T15:58:00.000Z" itemprop="datePublished">2024-03-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/14027/">第二课——线段树</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>

<p>上一节课讲了树状数组，也介绍了<strong>树状数组</strong>的优点与不足，这里简单回顾一下。<br>**优点：**树状数组的代码非常简短，易于实现，被刘老师亲切的称为IO选手的”HelloWorld!“，就是因为代码短。<br>**缺点：**树状数组的缺点也非常的明显，只能处理单点修改区间查询或者区间修改单点查询的问题（以较高的效率）。而区间修改区间查询的问题没有办法很优雅的解决，于是引出了线段树。</p>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>先来看一个问题：</p>
<hr>
<p><strong>7-1 张煊的金箍棒（2）</strong><br>张煊的金箍棒升级了！</p>
<p>升级后的金箍棒是由几根相同长度的金属棒连接而成（最开始都是铜棒，从1到N编号）；</p>
<p>张煊作为金箍棒的主人，可以对金箍棒施以任意的变换，每次变换操作就是将一段连续的金属棒（从X到Y编号）改为铜棒，银棒或金棒。</p>
<p>金箍棒的总价值计算为N个金属棒的价值总和。其中，每个铜棒价值为1；每个银棒价值为2；每个金棒价值为3。</p>
<p>现在，张煊想知道多次执行操作后的金箍棒总价值。<br><strong>输入格式:</strong></p>
<p>输入的第一行是测试数据的组数（不超过10个）。</p>
<p>对于每组测试数据，第一行包含一个整数N（1 &lt;&#x3D; N &lt;&#x3D; 100000），表示金箍棒有N节金属组成，第二行包含一个整数Q（0 &lt;&#x3D; Q &lt;&#x3D; 100,000），表示执行变换的操作次数。</p>
<p>接下来的Q行，每行包含三个整数X，Y，Z（1 &lt;&#x3D; X &lt;&#x3D; Y &lt;&#x3D; N，1 &lt;&#x3D; Z &lt;&#x3D; 3），它定义了一个操作：将从X到Y编号的金属棒变换为金属种类Z，其中Z &#x3D; 1代表铜棒，Z &#x3D; 2代表银棒，Z &#x3D; 3代表金棒。<br><strong>输出格式:</strong></p>
<p>对于每组测试数据，请输出一个数字，表示操作后金箍棒的总价值。</p>
<p>每组数据输出一行。<br><strong>输入样例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">9</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>可以看到题目中非常明显的区间修改+区间查询的意图，这也是线段树的一道入门题目。接下来我来介绍这个神奇的数据结构。</strong></p>
<h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>线段树由一个<strong>四倍原数组长</strong>的数组组成，对于数组中的元素也有着特殊的含义，但是比起树状数组来说要好理解多了。<br>首先我们不从数组层面来看这个数据结构，而是从一个二叉树，一棵完全二叉树。假设我们的原数组有8个数。那么线段数和原数组的关系就像这样：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240323142619781-1834453241_1726323704365.jpg" alt="image"><br>在线段树上的<strong>每一个节点</strong>表示对应区间的某个<strong>属性值</strong>，只要这个属性值<strong>满足区间的加法</strong>即可。<br>举个例子，这个<strong>属性值</strong>可以是<strong>区间和</strong>，可以是<strong>区间最值</strong>等等，这些具体的属性由题目来决定了，由于属性值的自由度极高，导致线段树在非常多的场合可以用于加速。</p>
<p>见过了线段树的二叉树形状，接下里给线段树一个数组的表示方式。这个也非常的简单：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240323143240787-396520700_1726323720978.jpg" alt="image"><br>和《数据结构》中一致，从根节点开始为 1 ，宽度优先搜索的顺序升序标号。有了标号，我们就能用数组来存储这棵二叉树了。可是<strong>为什么我们需要四倍的原数组空间呢</strong>？</p>
<p>这里我们从长度为5的数组开始，来探讨一下这个问题。<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240323145616173-2021873611_1726323720978.jpg" alt="image"><br>原数组长度为5，那么理论上黑色的节点已经够用了，但是我们使用的静态数组，一般会选择直接把完全二叉树所需的空间开出来，所以会用到最多四倍的空间。</p>
<h2 id="左右子结点的访问"><a href="#左右子结点的访问" class="headerlink" title="左右子结点的访问"></a>左右子结点的访问</h2><p>学过《数据结构》的读者可以跳过这块内容。<br>这部分比较简单，假设根的标志是1，那么左右子结点分别可以用以下两个函数访问：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> data[d&lt;&lt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> data[d&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];	<span class="comment">//等价于 d * 2 + 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微解释一下访问右节点的操作，一个二进制数在左移动后最低位一定是0，那么这时候可以用1与该数位或，就能得到乘2加一的效果。</p>
<h2 id="树的初始化"><a href="#树的初始化" class="headerlink" title="树的初始化"></a>树的初始化</h2><p>首先定义一下线段树的结构（代码层面）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SeqTree</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//方法定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">	&#125;data[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">&#125;seqTree;			<span class="comment">//线段树类</span></span><br><span class="line"><span class="type">int</span> arr[N];			<span class="comment">//原数组</span></span><br></pre></td></tr></table></figure>

<p>树的初始化是从原数组构造我们的线段树，以前面提到的题目为例子。节点的属性是<strong>区间和</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arr为原数组、l为区间左边、r为区间右边、rt为线段树上的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span>*arr,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;							<span class="comment">//到了叶子节点，直接赋值</span></span><br><span class="line">		data[rt].val = arr[l<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m = (l+r)&gt;&gt;<span class="number">1</span>;					<span class="comment">//寻找左右子结点的区间边界</span></span><br><span class="line">	<span class="built_in">build</span>(arr,l,m,rt&lt;&lt;<span class="number">1</span>);				<span class="comment">//递归构造两边的线段树</span></span><br><span class="line">	<span class="built_in">build</span>(arr,m<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">pushUp</span>(rt);							<span class="comment">//利用两边的子节点更新当前节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushUp</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	data[rt].val = data[rt&lt;&lt;<span class="number">1</span>].val + data[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现线段树的构造是非常容易理解的。由于二分的存在它的复杂度也只是O(NlogN)。</p>
<h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><p>线段树的修改，相当于修改最下层的某个节点，它会影响到上层的非常多节点，依照树的初始化的想法，我们可以很容易的写出修改代码，这里不提供。</p>
<h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><p>首先有一个理论保障：线段树的每次查询不会超过O(logN)的复杂度。为什么呢？</p>
<ul>
<li>任一连续区间至多由\(2log_2^N\)个子区间组成</li>
<li><ul>
<li>原因：任一区间不在线段树同一层出现两个子区间，并且树高不超过\(logN\)</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>原因的原因：因为区间连续，所以如果在同一层出现了两个子区间，那么这两个子区间一定可以合成上一层的一个区间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>所以查询的复杂度有了保障。于是我们来讲查询的思路。<br>对于一个区间查询\([L,R]\)，我们从根节点[0,4N]出发，进行二分查找，并把符合要求的区间上的节点都进行修改。<del>Idea is pool show me the code!</del></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区间查询[R,L]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> R,<span class="type">int</span> L,<span class="type">int</span> r,<span class="type">int</span> l,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(R&gt;l||L&lt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(R&lt;=r&amp;&amp;L&gt;=l)<span class="keyword">return</span> data[rt].val;</span><br><span class="line">	<span class="type">int</span> m = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">query</span>(R,L,r,m,rt&lt;&lt;<span class="number">1</span>)+<span class="built_in">query</span>(R,L,m<span class="number">+1</span>,l,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是超级简单？哈哈，刘老师说：“当年我们没有人教，没有题目刷的时候，学会了线段树就开始大杀四方，当时觉得是很稀奇的东西。你们今天倒好，随便就能学到如此有意思的算法。”</p>
<h2 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h2><p>这个就厉害了，不仅实现了区间修改，还引入了最高效的偷懒方式——lazy<br>思路是这样的：我们修改一个区间的时候，如果要把值给到每个受影响的节点，会非常的麻烦，并且涉及到多次修改时，程序的复杂度会较高。但是仔细想想，我们线段树上的节点不是能代表<strong>属性</strong>么，那是不是也可以记录修改的属性呢？于是<strong>lazy</strong>诞生了。<br><strong>修改一个区间的时候，我们不修改对应的叶子节点，而是在最上层的区间节点上记录本次修改，并在查询的时候应用。</strong><br>我们首先修改一下数据结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SeqTree</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//方法定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">		<span class="type">int</span> lazy;	<span class="comment">//lazy标志</span></span><br><span class="line">	&#125;data[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">&#125;seqTree;			<span class="comment">//线段树类</span></span><br><span class="line"><span class="type">int</span> arr[N];			<span class="comment">//原数组</span></span><br></pre></td></tr></table></figure>

<p>然后重写之前的各个方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span>*arr,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		data[rt].val = arr[l<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	data[rt].lazy = <span class="number">0</span>;										<span class="comment">//给lazy初始化值</span></span><br><span class="line">	<span class="built_in">build</span>(arr,l,m,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">build</span>(arr,m<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">pushUp</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询[R,L]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> R,<span class="type">int</span> L,<span class="type">int</span> r,<span class="type">int</span> l,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(R&gt;l||L&lt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(R&lt;=r&amp;&amp;L&gt;=l)<span class="keyword">return</span> data[rt].val;</span><br><span class="line">	<span class="type">int</span> m = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">pushDown</span>(rt,m-r<span class="number">+1</span>,l-m);									<span class="comment">//新加了一个应用lazy的函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">query</span>(R,L,r,m,rt&lt;&lt;<span class="number">1</span>)+<span class="built_in">query</span>(R,L,m<span class="number">+1</span>,l,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间修改把[R,L]修改为C</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> R,<span class="type">int</span> L,<span class="type">int</span> C,<span class="type">int</span> r,<span class="type">int</span> l,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(R&gt;l||L&lt;r)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(R&lt;=r&amp;&amp;L&gt;=l)&#123;</span><br><span class="line">		data[rt].val=C*(l-r<span class="number">+1</span>);								<span class="comment">//更新节点值</span></span><br><span class="line">		<span class="keyword">if</span>(r&lt;l)</span><br><span class="line">			data[rt].lazy=C;								<span class="comment">//查询到此，继承lazy值</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">pushDown</span>(rt,m-r<span class="number">+1</span>,l-m);									<span class="comment">//应用lazy</span></span><br><span class="line">	<span class="built_in">update</span>(R,L,C,r,m,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">update</span>(R,L,C,m<span class="number">+1</span>,l,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">pushUp</span>(rt);												<span class="comment">//这里有一个细节，应用lazy要在向上计算value之前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是应用lazy的函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushDown</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> rn,<span class="type">int</span> ln)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(data[rt].lazy)&#123;</span><br><span class="line">		data[rt&lt;&lt;<span class="number">1</span>].val=data[rt].lazy*rn;</span><br><span class="line">		data[rt&lt;&lt;<span class="number">1</span>].lazy=data[rt].lazy;</span><br><span class="line">		data[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val=data[rt].lazy*ln;</span><br><span class="line">		data[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy=data[rt].lazy;</span><br><span class="line">		data[rt].lazy=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就讲完了，线段树我似乎没有进行多少理论的分析，大部分都是show you the code.但是线段树是一个抽象的，强大的优化工具，而不是一个算法。想要理解线段树，还需要自己去编码实现。这里提供完整的程序代码供你参考。</p>
<p>点击查看代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqTree</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="built_in">sizeof</span>(Data)*(size&lt;&lt;<span class="number">2</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(size&lt;&lt;<span class="number">2</span>);i++)&#123;</span><br><span class="line">			data[i].val = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushUp</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">		data[rt].val = data[rt&lt;&lt;<span class="number">1</span>].val + data[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushDown</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> rn,<span class="type">int</span> ln)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(data[rt].lazy)&#123;</span><br><span class="line">			data[rt&lt;&lt;<span class="number">1</span>].val=data[rt].lazy*rn;</span><br><span class="line">			data[rt&lt;&lt;<span class="number">1</span>].lazy=data[rt].lazy;</span><br><span class="line">			data[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val=data[rt].lazy*ln;</span><br><span class="line">			data[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy=data[rt].lazy;</span><br><span class="line">			data[rt].lazy=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span>*arr,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">			data[rt].val = arr[l<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> m = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		data[rt].lazy = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">build</span>(arr,l,m,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">build</span>(arr,m<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">pushUp</span>(rt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//区间查询[R,L]</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> R,<span class="type">int</span> L,<span class="type">int</span> r,<span class="type">int</span> l,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(R&gt;l||L&lt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(R&lt;=r&amp;&amp;L&gt;=l)<span class="keyword">return</span> data[rt].val;</span><br><span class="line">		<span class="type">int</span> m = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">pushDown</span>(rt,m-r<span class="number">+1</span>,l-m);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">query</span>(R,L,r,m,rt&lt;&lt;<span class="number">1</span>)+<span class="built_in">query</span>(R,L,m<span class="number">+1</span>,l,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> R,<span class="type">int</span> L,<span class="type">int</span> C,<span class="type">int</span> r,<span class="type">int</span> l,<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(R&gt;l||L&lt;r)&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(R&lt;=r&amp;&amp;L&gt;=l)&#123;</span><br><span class="line">			data[rt].val=C*(l-r<span class="number">+1</span>);</span><br><span class="line">			<span class="keyword">if</span>(r&lt;l)</span><br><span class="line">				data[rt].lazy=C;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> m = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">pushDown</span>(rt,m-r<span class="number">+1</span>,l-m);</span><br><span class="line">		<span class="built_in">update</span>(R,L,C,r,m,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">update</span>(R,L,C,m<span class="number">+1</span>,l,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">pushUp</span>(rt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;############## debug ##############\n&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(size&lt;&lt;<span class="number">2</span>);i++)&#123;</span><br><span class="line">			cout&lt;&lt;data[i].val&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;data[i].lazy&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;############## debug ##############\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">		<span class="type">int</span> lazy;</span><br><span class="line">	&#125;data[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">&#125;seqTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> b,n,q;</span><br><span class="line">	cin&gt;&gt;b;</span><br><span class="line">	<span class="keyword">while</span>(b--)&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">		seqTree.<span class="built_in">clear</span>(n);</span><br><span class="line">		<span class="type">int</span> x,y,z;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q;i++)&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">			seqTree.<span class="built_in">update</span>(x,y,z,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;seqTree.<span class="built_in">query</span>(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="comment">// seqTree.debug(n);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好好领悟线段树的<strong>节点属性</strong>吧。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-算法基础/第一课——树状数组" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/53666/" class="article-date">
      <time datetime="2024-03-15T17:17:00.000Z" itemprop="datePublished">2024-03-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/53666/">第一课——树状数组</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>

<p><strong>前缀和算法</strong>可以计算某一个区间的累记和，但是出现修改的时候，前缀和的效率便得不到保障。于是<strong>数状数组</strong>出现了。出现原因总结——需求从<strong>单纯的区间查询</strong>变为了<strong>单点修改 + 区间查询</strong>。</p>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>本文不探讨树状数组的开发过程，这里先给出树状数组的结构：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/undefined/img/3080748-20240315162808906-181852761_1726323720978.jpg" alt="image"><br>树状数组的设计非常巧妙，它让下标为\(i\)（从1开始）的位置存储原数组的部分和。比如下标为2的位置，存储了前两个数据的和，而下标为4的位置存储了前四个数据的和。<br>但是也有些特殊的位置，比如6。你会发现，虽然它是偶数下标，但是它并没有存储前6个数据，而是只存储了5、6两个数据。下面给出树状数组的<strong>核心机制</strong>\(lowbit\)。</p>
<h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit()"></a><code>lowbit()</code></h3><p>\(lowbit\)的定义是：<strong>一个二进制数的低位零的个数。</strong><br>比如，2 的二进制是 10 ，那么 \(lowbit(2)\) &#x3D; 1 。<br>而 6 的二进制是110，<strong>所以和2一样</strong> \(lowbit(6)\) &#x3D; 1。<br>于是我们可以给出树状树组下标为 \(i\) 的位置的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeArr[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">lowbit</span>(i) ; j++)TreeArr[i] +=data[i-j];</span><br></pre></td></tr></table></figure>

<p>这里我直接写了<code>C++</code>的代码，但是阅读应该没有困难。其中<code>data</code>是原数组的数据，<code>TreeArr</code>是我们构造的树状数组。</p>
<h4 id="lowbit-函数的实现"><a href="#lowbit-函数的实现" class="headerlink" title="lowbit()函数的实现"></a><code>lowbit()</code>函数的实现</h4><p>\(lowbit\)函数有两种实现方式，其中第一种是比较容易理解的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x - (x &amp; (x - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种是比较抽象的，但是我个人比较喜欢，因为它更加的简洁优美。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i &amp; -i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个有兴趣的朋友可以自己推导一下，不过也不会很复杂的。</p>
<h3 id="update-int-i-int-data-函数"><a href="#update-int-i-int-data-函数" class="headerlink" title="update(int i,int data)函数"></a><code>update(int i,int data)</code>函数</h3><p>然后我来看一下单点更新如何在树状数组这样奇怪的数据结构上实现。<br>首先这个操作传入两个参数，一个是在原数组的位置，另一个是修改后的数值。再来看一下树状数组的结构：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/undefined/img/3080748-20240315162808906-181852761_1726323720978.jpg" alt="image"><br>假设我<strong>给<code>data[3]</code>加上一个<code>1</code></strong>，那么<strong>树状数组中</strong>受到影响的节点有<code>3</code>、<code>4</code>、<code>8</code>，不难发现，我们可以从底部的<code>3</code>出发，自下而上的找出所有被影响的点，而<code>4</code> &#x3D; <code>3 + lowbit(3)</code>、<code>8</code> &#x3D; <code>4 + lowbit(4)</code>，是不是非常的妙？前推和后推都回到了\(lowbit\)上，不然怎么数\(lowbit\)是树状数组的核心机制呢？<br>有了这个理论基础，我们就能轻松的写出\(update\)函数的代码了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i ,<span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; n)&#123;				<span class="comment">// n 是数组的长度</span></span><br><span class="line">	TreeArr[i] += data;</span><br><span class="line">	i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出这是一个**O(lgN)**的更新操作。</p>
<h3 id="Sum-int-j-函数"><a href="#Sum-int-j-函数" class="headerlink" title="Sum(int j)函数"></a><code>Sum(int j)</code>函数</h3><p><code>Sum(int j)</code>函数实现了原数组中前<code>j</code>个数据的求和。<br>前面提到过，<code>TreeArr[i]</code>包括了从<code>i</code>开始的往前数<code>lowbit(i)</code>个数据的和，那么在求前 <code>j</code>个数据的和时，我们可以利用和更新中类似的方法，每次计算当前<code>lowbit(j)</code>个数据的和，然后去到<code>j \- lowbit(j)</code>的位置继续求前面的值。代码如下，也是非常的简洁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> rest = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		rest += TreeArr[j];</span><br><span class="line">		j -= <span class="built_in">lowbit</span>(j);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出这是一个**O(lgN)**的求和。</p>
<h3 id="应用：单点更新区间查询"><a href="#应用：单点更新区间查询" class="headerlink" title="应用：单点更新区间查询"></a>应用：单点更新区间查询</h3><p><strong>P3374 【模板】树状数组 1</strong><br><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3374">https://www.luogu.com.cn/problem/P3374</a></p>
<h3 id="区间更新-单点查询"><a href="#区间更新-单点查询" class="headerlink" title="区间更新 + 单点查询"></a>区间更新 + 单点查询</h3><p>这时，我们的需求改变了，我们不再需要区间查询了，而只要单点查询，但是需要实现区间修改。这时我们可以使用到一个数学概念——<strong>差分</strong>。使用<strong>差分</strong>作为树状数组存储的内容，可以让树状树组从<strong>单点修改 + 区间查询</strong>变为<strong>区间修改 + 单点查询</strong>。</p>
<h4 id="差分的定义"><a href="#差分的定义" class="headerlink" title="差分的定义"></a>差分的定义</h4><p>假设<code>d[n]</code>是一个差分数组，那么：</p>
<p>\[d[n] &#x3D; data[n] - data[n-1] \]</p>
<p>非常好理解，如果我要修改全部的数据，比如把所有数据加 1，那么我们只需要在第一个位置加上一就好了，因为差分数组的性质，其他的位置值并不需要修改。<br>那么如果我们要进行单点的查询，比如 <code>data[n]</code>（原数据），就需要计算前<code>d</code>数组的前<code>n</code>项和。这一就完美地完成了从<strong>单点修改 + 区间查询</strong>变为<strong>区间修改 + 单点查询</strong>的过程。</p>
<h2 id="树状数组的不足"><a href="#树状数组的不足" class="headerlink" title="树状数组的不足"></a>树状数组的不足</h2><p>当我们的问题变成<strong>区间修改 + 区间查询</strong>时，树状树组便不能完成这个工作了（一维），我们需要更好的数据结构，下节课——<strong>线段树</strong>完美解决树状数组的问题。<br><del>PS：其实并不是，树状树组的内存是(N)，而线段树需要(N&lt;&lt;2)也就是原数组四倍的内存空间。</del></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-CG/B-Spline" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/17428/" class="article-date">
      <time datetime="2024-01-30T20:28:00.000Z" itemprop="datePublished">2024-01-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/17428/">B-Spline</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>

<h1 id="B-Spline"><a href="#B-Spline" class="headerlink" title="B-Spline"></a>B-Spline</h1><p>注：<br>本文只是作者自己对B样条的理解和实现，如有错误欢迎指出，谢谢。<br>作者邮箱：zhywyt@hdu.edu.cn<br><strong>B-Spline 是图形学中非常基础的一个曲线，我的导师徐岗徐老师，让我们从 B样条的绘制开始，无疑是一个很好的开始。</strong></p>
<p>同 Bezier 曲线，B样条也是一个由伯恩斯坦基函数加权得到的曲线，因此它和 Bezier 曲线有这很多的相似点，这里我们把 Bezier 曲线和 B 样条放在一起来研究。</p>
<p><strong>贝塞尔曲线：</strong></p>
<p>\[\vec{P(t)}&#x3D;\sum_{i&#x3D;0}^{n-1}\vec{p_i}B_{i,n}(t),t \in [0, 1] \]</p>
<p><strong>B 样条曲线：</strong></p>
<p>\[\vec{P(t)}&#x3D;\sum_{i&#x3D;0}^{n-1}\vec{p_i}B_{i,d}(t)，其中 t_{min}\leq t \leq t_{max}，2\leq d \leq n \]</p>
<p>可以看到两个曲线的区别就在于基函数的定义：Bezier 曲线的基函数只与曲线的控制点数有关，曲线的控制点数就确定了曲线的阶数；而 B 样条的基函数中，n 换成了 d ，这也意味着曲线的控制点数不再决定曲线的阶数，而是独立的一个自由度。</p>
<p><strong>下面是我的一些符号规定：</strong></p>
<p>\[\begin{array} {cll} \hline 参数名 &amp; 符号 \\ \hline 参数 &amp; t\\ 顶点数 &amp; n+1 \\ 曲线阶数 &amp; p \ \&amp;\ d \\ 控制顶点 &amp; P_i \\ 下标为\ i \ 的节点向量 &amp; u_i \\ 基函数的次数 &amp; p-1\\ 第\ i+1\ 个控制顶点的\ j\ 阶基函数 &amp; B(i,j)\\ 头节点重数 &amp; h \\ 节点向量个数 &amp; n+p \\ 自由度 &amp; n,p,h\\ \hline \end{array} \]</p>
<p><strong>解释：曲线阶数在数学中我一般使用\(d\)，而在代码中我喜欢使用\(p\)</strong></p>
<h2 id="为什么要修改基函数？"><a href="#为什么要修改基函数？" class="headerlink" title="为什么要修改基函数？"></a>为什么要修改基函数？</h2><p><strong>众所周知，Bezier 曲线的一大缺陷就是曲线的定义是全局的，移动一个控制点就会影响整条曲线，但是设计上往往希望能够局部修改。于是产生了分段 Bezier 曲线，但是新的问题出现了：分段 Bezier 曲线的连续性很难保证，不能达到很好的效果。B 样条因此诞生，以修改基函数的方式达到目的。</strong></p>
<h2 id="为什么修改基函数可以达到这个效果？"><a href="#为什么修改基函数可以达到这个效果？" class="headerlink" title="为什么修改基函数可以达到这个效果？"></a>为什么修改基函数可以达到这个效果？</h2><p><strong>B 样条曲线：</strong></p>
<p>\[\vec{P(t)}&#x3D;\sum_{i&#x3D;0}^{n-1}\vec{p_i}B_{i,d}(t)，其中 t_{min}\leq t \leq t_{max}，2\leq d \leq n \]</p>
<p><strong>再来理解一下曲线的定义，每个控制点，在参数 t 处的对曲线影响的权值由基函数控制。要控制每个点的影响范围，就需要定义基函数的非零区间，在非零区间里，该控制点就对曲线有影响，而在零区间，就没有任何影响。这样的话，就能控制每个点对曲线影响的范围了。</strong><br>在此之前，先介绍一下节点向量的概念。</p>
<h3 id="B样条的节点向量"><a href="#B样条的节点向量" class="headerlink" title="B样条的节点向量"></a>B样条的节点向量</h3><p><strong>节点向量</strong>描述了B样条曲线上某一<strong>参数 t</strong>对应基函数的哪一部分。你可以把它想象成<strong>一部电影的时间线</strong>，给定一个时间就能得到相应的画面，而B样条就是给定<strong>一个参数 t</strong>就能得到<strong>对应的坐标</strong>。<br>下面是一个例子：</p>
<ul>
<li><strong>\(P_i:\) 第 i 个控制点</strong></li>
<li><strong>\(u_i:\) 下标为 i 的节点向量的值</strong><br>下图是一个有五个控制顶点的(\(n+1&#x3D;5\))，四阶B样条(\(p&#x3D;4\))。\([u_0 , u_8]\)就是节点向量了，而上面画的曲线则是<strong>某个控制点</strong>对下面的区间的<strong>参数</strong>的权值。给定一个节点向量，就能唯一确定一个基函数的对应关系，比如最简单的，\(u_0\)对应参数的点，只被\(P_1\)这个点所影响，而\(u_3\)却被\(P_1，P_2，P_3，P_4\)四个点所影响。当然，你会发现区间\([u_0 , u_3]\)其实是被小于曲线阶数的顶点所影响的，它的权值和不等于一，这不满足B样条曲线的性质，实际上B样条的定义不从\(u_0\)开始，\(u_0\)的存在仅仅是为了其他区间的计算权值。这也就反映了B样条<strong>参数的定义域</strong>了。不是\([0,1]\)而是根据节点向量的\([u_{p-1},u_{n+1}]\)在下面这个例子中是区间\([u_3 , u_5]\)。<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20231219093349422-1400639285_1726323760639.png" alt="image"><br><strong>可以很清楚的看到，\(P_1\)控制点不会影响到\(u_5\)及以后的曲线。每一段曲线比如\([u_3, u_4]\)只由\(P_1 - P_4\)四个控制点所影响，实现了曲线的局部控制。</strong></li>
</ul>
<h2 id="这样的基函数如何定义？"><a href="#这样的基函数如何定义？" class="headerlink" title="这样的基函数如何定义？"></a>这样的基函数如何定义？</h2><p>从一个简单的一阶基函数定义看起：</p>
<p>\[B_{k,1}(u) \begin{cases} 1 , u[k]\leq u\leq u[k+1]\\ 0 , else \end{cases} \]</p>
<p><strong>它只有在自己的定义区间内才有值 1，其余部分都为 0。</strong><br>画出来也非常的清晰：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20231219195844903-1069132022_1726323760639.png" alt="image"><br>那么如果要进行升阶，我们就需要使用<strong>两个定义在相邻区间的一阶基函数</strong>：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20231219200010972-39138952_1726323760639.png" alt="image"><br>通过一个简单的线性组合就能得到二阶的基函数：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20231219200102011-907521753_1726323781567.png" alt="image"><br>可以看到这个基函数的定义域成为了两个低阶基函数定义域的并集，从定义上看这个线性组合就是：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20231219200222268-1957786021_1726323781567.png" alt="image"><br>先不要害怕两个奇怪的权值，观察上面的一阶到二阶的加权不难发现，这两个权值其实是曲线在参数为 u 处的简单加权。<strong>也就是上面出现过的一次加权直线的函数取值</strong>。但是你可能会觉得奇怪，当\(u\leq u_{k+1}\)的时候，第二项的权值好像大于一了？！这不对吧？</p>
<p><strong>实际上在\(u\leq u_{k+1}\)的时候，右边这一项\(B_{k+1,d-1}(u)\)的值等于零了。</strong></p>
<p>看下面这个图，计算三阶基函数会显得更清晰：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20231220083544752-147171411_1726323781567.png" alt="image"><br><strong>于是我们得到完整的 B 样条数学定义：</strong></p>
<p>\[\begin{cases} \begin{cases} 1 , u_k \leq u\leq u_{k+1}\\ 0 , else \end{cases} \quad ,k &#x3D; 1 \\ B_{k,d}(u)&#x3D;\frac{u-u_k}{u_{k+d-1}-u_k}B_{k,d-1}(u)+\frac{u_{k+d}-u}{u_{k+d}-u_{k+1}}B_{k+1,d-1}(u) \quad ,k \ge 2 \end{cases} \]</p>
<h2 id="B样条的自由度"><a href="#B样条的自由度" class="headerlink" title="B样条的自由度"></a>B样条的自由度</h2><p>说到 B 样条，就不得不说说它的自由度了。相比于 Bezier 曲线仅有的一个自由度（顶点数），<strong>均匀</strong>B 样条的自由度可多达三个（个人理解）：<strong>顶点数、曲线阶数、头节点重数设置</strong>（非均匀B样条修改为节点向量的设置即可）。<del>姑且允许我这么随便的称呼自由度</del>，可能不是那么标准，但是我是想让你明白 B 样条需要设置哪些参数。这里，我们讨论的是（准）均匀节点的 B 样条，也就是<strong>节点向量只会在头和尾相等而在中间以相同速率增加</strong>。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n+1	: 5			number of control points.</span><br><span class="line">p	: 4			rank of BSpline.</span><br><span class="line">h	: 1			repeat of <span class="built_in">head</span> and <span class="built_in">tail</span>.</span><br><span class="line">nv	: 9			number of node vector.</span><br><span class="line"><span class="built_in">head</span> vector:</span><br><span class="line">0 0.111111 0.222222 0.333333 0.444444 0.555556 0.666667 0.777778 1 </span><br><span class="line">//change para of B-Spline</span><br><span class="line">n+1	: 5			number of control points.</span><br><span class="line">p	: 3			rank of BSpline.</span><br><span class="line">h	: 3			repeat of <span class="built_in">head</span> and <span class="built_in">tail</span>.</span><br><span class="line">nv	: 8			number of node vector.</span><br><span class="line"><span class="built_in">head</span> vector:</span><br><span class="line">0 0 0 0.25 0.5 1 1 1</span><br></pre></td></tr></table></figure>

<p>相信你们顶点数和曲线阶数一定都能理解意思，那么我来解释一下头节点重数的定义：</p>
<h3 id="头节点重数的作用"><a href="#头节点重数的作用" class="headerlink" title="头节点重数的作用"></a>头节点重数的作用</h3><p><strong>头节点重数：</strong> 头节点重数是用来描述节点向量头和尾的重合个数的。首先，一个节点向量是单调不减的，而我们讨论的又是均匀节点的 B 样条曲线，所以头节点重数就可以完整的控制节点向量的生成。</p>
<p><strong>而节点向量就能定义控制点对曲线的影响。</strong></p>
<p>下面举两个直观的例子来带你了解头节点重数的作用。<br>首先我们绘制一个正常的 B 样条曲线，设置它的<strong>头节点重数为一</strong>：<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20231221235653628-1502374889_1726323781567.png" alt="image"><br>然后我们修改它的头节点重数，使得<strong>头节点重数</strong>等于<strong>基函数阶数</strong>。<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20231221235700214-45778439_1726323781567.png" alt="image"><br>会发现，头节点重数可以使得<strong>曲线插值端点</strong>。下面我用两个图来从基函数的层面带你理解头节点重数为什么能够影响曲线。首先是<strong>一张有五个控制顶点的4阶B样条的基函数关系图</strong>。<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240130105341642-2012485333_1726323797901.jpg" alt="image"><br><strong>如果现在让头和尾重合一部分。比如 \(h &#x3D; p\) 也就是头节点重数等于曲线的阶数。节点向量就会变成下面这样：</strong></p>
<p>\[\begin{cases} u_0 &#x3D; u_1 &#x3D; u_2 &#x3D; u_3 &#x3D; 0 \\ u_8 &#x3D; u_ 7 &#x3D; u_6 &#x3D; u_5 &#x3D; 1 \\ u_4 &#x3D; 0.5 \\ \end{cases} \]</p>
<p>让我们把节点向量的值写到基函数的关系图上去。<strong>红色部分的基函数由于区间为零</strong>，<strong>值恒为零</strong>。所以可以看到不为零的基函数构成了<strong>伯恩斯坦基函数</strong>，也就是<strong>Bezier曲线同款基函数</strong>。<br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20240130110237018-1169657684_1726323797901.jpg" alt="image"></p>
<h4 id="B样条退化为Bezier曲线"><a href="#B样条退化为Bezier曲线" class="headerlink" title="B样条退化为Bezier曲线"></a>B样条退化为Bezier曲线</h4><p>再想象一下，如果控制点的个数减少一个，也就是 \(n+1 &#x3D; p\) ，控制点的个数等于曲线阶数，并且满足头节点重数等于曲线阶数的时候，<strong>中间非零的节点区间只剩下了一个</strong>，这个时候，<strong>B样条真正的退化为了Bezier曲线</strong>。总结一下，B样条退化为Bezier曲线的条件：</p>
<ul>
<li><strong>1.控制顶点个数等于曲线阶数</strong> \(\quad\) \(n+1 &#x3D; p\)</li>
<li><strong>2.头节点重数等于曲线阶数</strong> \(\quad\) \(h &#x3D; p\)</li>
</ul>
<h2 id="B样条的实现"><a href="#B样条的实现" class="headerlink" title="B样条的实现"></a>B样条的实现</h2><p>这部分其实不难，如果完全理解了B样条真的是非常简单的实现，但是如果不清楚自己是否完全理解了B样条的思想，可以动手实现一下，这里提供实现思路和源代码。这个项目中我用到了几个绘制算法，你无需理解他们是如何工作的，只需要像调用函数一样调用它即可。如果想要使用我的框架进行B样条曲线的学习，请确保自己有看懂C++简单代码的能力，以及稍微阅读一下函数接口的使用。这篇文章会介绍B样条曲线实现用到的所有接口。如果对算法感兴趣的同学也可以去看一下这几个绘制算法的具体实现。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhywyt/p/17340739.html">直线的绘制</a>\(\quad\)<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhywyt/articles/17341756.html">圆形的绘制</a>\(\quad\)<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhywyt/p/17347089.html">橡皮筋技术</a></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>请先下载项目源代码，并保证根据<strong>README</strong>的指导可以让程序跑起来。这个项目提供了linux和windows两个操作系统的编译方案。windows使用VS进行编译，linux使用cmake进行编译。<br><a target="_blank" rel="noopener" href="https://gitee.com/zhy2216095277/b-spline" title="gitee">B-Spline</a><br>其中CMakeLists.txt文件的内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#项目信息</span></span><br><span class="line"><span class="keyword">project</span>(BSpline)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找当前目录下所有源文件</span></span><br><span class="line"><span class="comment">#并将文件名保存在DIR_SOURECE</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SOURCE)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;DIR_SOURCE&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(GLUT REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(OpenGL REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(GLUT_FOUND)</span><br><span class="line">    <span class="keyword">include_directories</span>(<span class="variable">$&#123;GLUT_INCLUDE_DIR&#125;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;GLUT_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">else</span>(GLUT_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR ”GLUT library <span class="keyword">not</span> found”)</span><br><span class="line"><span class="keyword">endif</span>(GLUT_FOUND)</span><br><span class="line"><span class="keyword">if</span>(OPENGL_FOUND)</span><br><span class="line">    <span class="keyword">include_directories</span>(<span class="variable">$&#123;OPENGL_INCLUDE_DIR&#125;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;OPENGL_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">else</span>(OPENGL_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR ”OpenGL library <span class="keyword">not</span> found”)</span><br><span class="line"><span class="keyword">endif</span>(OPENGL_FOUND)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定生成目标</span></span><br></pre></td></tr></table></figure>

<h3 id="b-spline-basis"><a href="#b-spline-basis" class="headerlink" title="b_spline_basis"></a>b_spline_basis</h3><p>这将是我们要实现的第一个函数，b_spline_basis，函数原型如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLdouble <span class="title">b_spline_basis</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> p, GLdouble u, <span class="type">const</span> vector&lt;GLdouble&gt; &amp;nodeVec)</span></span></span><br></pre></td></tr></table></figure>

<p>接受 （<code>i</code>，<code>p</code>，<code>u</code>），返回下标为<code>i</code>的控制点的<code>p</code>阶基函数在参数<code>u</code>处的函数值。<br>首先编写一阶的基函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == <span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> (nodeVec[i] &lt;= u &amp;&amp; u &lt;= nodeVec[i + <span class="number">1</span>])</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一阶之外的基函数，首先计算两个权值的分母：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLdouble len1 = nodeVec[i + p - <span class="number">1</span>] - nodeVec[i];</span><br><span class="line">GLdouble len2 = nodeVec[i + p] - nodeVec[i + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>然后利用递归计算两个区间的子基函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLdouble alpha, beta;</span><br><span class="line">alpha = (u - nodeVec[i]) / len1;</span><br><span class="line">beta = (nodeVec[i + p] - u) / len2;</span><br><span class="line"><span class="keyword">return</span> (alpha)*<span class="built_in">b_spline_basis</span>(i, p - <span class="number">1</span>, u, nodeVec) + (beta)*<span class="built_in">b_spline_basis</span>(i + <span class="number">1</span>, p - <span class="number">1</span>, u, nodeVec);</span><br></pre></td></tr></table></figure>

<p>由于出现了对<code>len1</code>和<code>len2</code>的除法，所以需要检测区间的长度，避免浮点误差导致的离群点。而且u的区间也不能超过基函数的定义区间，需要把上面代码修改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (u &lt; nodeVec[i] || u &gt; nodeVec[i + p])			<span class="comment">//限制参数区间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">GLdouble len1 = nodeVec[i + p - <span class="number">1</span>] - nodeVec[i];</span><br><span class="line">GLdouble len2 = nodeVec[i + p] - nodeVec[i + <span class="number">1</span>];</span><br><span class="line">GLdouble alpha, beta;</span><br><span class="line"><span class="keyword">if</span> (len1 &lt;= <span class="number">1e-10</span>)&#123;									<span class="comment">//避免浮点误差导致的错误</span></span><br><span class="line">	alpha = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	alpha = (u - nodeVec[i]) / len1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len2 &lt;= <span class="number">1e-10</span>)&#123;</span><br><span class="line">	beta = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	beta = (nodeVec[i + p] - u) / len2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (alpha)*<span class="built_in">b_spline_basis</span>(i, p - <span class="number">1</span>, u, nodeVec) + (beta)*<span class="built_in">b_spline_basis</span>(i + <span class="number">1</span>, p - <span class="number">1</span>, u, nodeVec);</span><br></pre></td></tr></table></figure>

<p>然后就能得到完整的基函数计算方法了。下面是完整代码的展示。</p>
<p>b_spline_basis</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLdouble <span class="title">b_spline_basis</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> p, GLdouble u, <span class="type">const</span> vector&lt;GLdouble&gt; &amp;nodeVec)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (nodeVec[i] &lt;= u &amp;&amp; u &lt;= nodeVec[i + <span class="number">1</span>])</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (u &lt; nodeVec[i] || u &gt; nodeVec[i + p])</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	GLdouble len1 = nodeVec[i + p - <span class="number">1</span>] - nodeVec[i];</span><br><span class="line">	GLdouble len2 = nodeVec[i + p] - nodeVec[i + <span class="number">1</span>];</span><br><span class="line">	GLdouble alpha, beta;</span><br><span class="line">	<span class="keyword">if</span> (len1 &lt;= <span class="number">1e-10</span>)&#123;</span><br><span class="line">		alpha = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="keyword">else</span>&#123;</span><br><span class="line">		  alpha = (u - nodeVec[i]) / len1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (len2 &lt;= <span class="number">1e-10</span>)&#123;</span><br><span class="line">		beta = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		beta = (nodeVec[i + p] - u) / len2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (alpha)*<span class="built_in">b_spline_basis</span>(i, p - <span class="number">1</span>, u, nodeVec) + (beta)*<span class="built_in">b_spline_basis</span>(i + <span class="number">1</span>, p - <span class="number">1</span>, u, nodeVec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h3><p>然后可以开始实现绘制算法了。<br>绘制算法首先要计算参数对应点的坐标，这个坐标等于每一个控制点在参数<code>u</code>处的贡献。下面代码很好理解，我就只提一点，GLUT的使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GLdouble basis;</span><br><span class="line"><span class="function">vector&lt;GLdouble&gt; <span class="title">rx</span><span class="params">(node, <span class="number">0</span>)</span>, <span class="title">ry</span><span class="params">(node, <span class="number">0</span>)</span></span>;</span><br><span class="line">GLdouble u_begin = m_nodeVec[p<span class="number">-1</span>];					<span class="comment">//注意开始参数与结尾参数</span></span><br><span class="line">GLdouble u_end = m_nodeVec[m_n<span class="number">+1</span>];</span><br><span class="line">GLdouble dis = (u_end - u_begin) / node;</span><br><span class="line">GLdouble u = u_begin;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node; i++) &#123;</span><br><span class="line">	 <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m_n; j++)&#123;</span><br><span class="line">		basis = <span class="built_in">b_spline_basis</span>(j, p, u, m_nodeVec);</span><br><span class="line">		rx[i] += m_points[j].x * basis;</span><br><span class="line">		ry[i] += m_points[j].y * basis;</span><br><span class="line">	&#125;</span><br><span class="line">u += dis;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glBegin</span>(GL_POINTS);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node; i++)&#123;</span><br><span class="line">	<span class="built_in">glVertex2d</span>(rx[i], ry[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br><span class="line"><span class="built_in">glFlush</span>();</span><br></pre></td></tr></table></figure>

<p>本项目中，只使用了GLUT的<strong>点绘制功能</strong>，虽然它内置的算法大多比我写的高效，但是毕竟是学习目的，了解绘制算法的底层对自己没有坏处。<code>glVertex2d(int x,int y)</code>可以在屏幕上绘制出一个在(x, y)的点，非常的简单。<br>好了就讲这么多了，其余的还请大家自己看源代码了，核心代码就这么多了，下次见。白白</p>
<h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>如果有小伙伴发现了本文的错误，请您第一时间联系我，我会感激不尽。<br>作者邮箱：<strong>zhywyt@hdu.edu.cn</strong><br>或者：<strong>zhywyt_6.10@qq.com</strong><br><strong>又或者您可以直接到我的<a target="_blank" rel="noopener" href="https://gitee.com/zhy2216095277/b-spline/issues" title="issue">gitee</a>项目中提出issue，我有时间一定会继续更新代码的。</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/CG/">CG</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-算法基础/花期内的花的数目" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/16515/" class="article-date">
      <time datetime="2023-10-08T18:32:00.000Z" itemprop="datePublished">2023-10-08</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/16515/">花期内的花的数目</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-flowers-in-full-bloom/solutions/2457828/hua-qi-nei-hua-de-shu-mu-by-leetcode-sol-j94l/?envType=daily-question&envId=2023-09-28">2251.花期内的花的数目</a><br><strong>看到题目的第一想法是桶排序，但是想想肯定会超时，在题解区看到了这么一种解法，感觉很有意思，就记录一下。</strong><br><strong>要统计某一时间内多少花开放，也就是统计某一时间有多少花开放在它之前，结束在它之后。因为一朵花的开始一定是比结束早的，所以并不需要关心匹配问题。</strong><br><strong>使用两个数组分别存储花开与花谢的日期，排序后使用二分法即可快速得到某一日期的花开数量。</strong></p>
<ul>
<li><strong>优点 ：不用存储花期的对应关系。</strong></li>
<li><strong>缺点 ： 不能确定是哪些花在这天会开放。</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fullBloomFlowers</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; flowers, vector&lt;<span class="type">int</span>&gt;&amp; persons)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = flowers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">starts</span><span class="params">(n)</span>, <span class="title">ends</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            starts[i] = flowers[i][<span class="number">0</span>];</span><br><span class="line">            ends[i] = flowers[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(starts.<span class="built_in">begin</span>(), starts.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(ends.<span class="built_in">begin</span>(), ends.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> m = persons.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">upper_bound</span>(starts.<span class="built_in">begin</span>(), starts.<span class="built_in">end</span>(), persons[i]) - starts.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">lower_bound</span>(ends.<span class="built_in">begin</span>(), ends.<span class="built_in">end</span>(), persons[i]) - ends.<span class="built_in">begin</span>();</span><br><span class="line">            ans[i] = x - y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-算法基础/简单的拓扑排序" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/11458/" class="article-date">
      <time datetime="2023-09-15T10:43:00.000Z" itemprop="datePublished">2023-09-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/11458/">简单的拓扑排序</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>

<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/graph/topo">[OI WiKi]什么是拓扑排序?</a><br><strong>简单来说，拓扑排序要解决的问题是给一个有向无环图的所有节点排序。</strong><br><strong>使用一个队列维护入度为零的节点，取出队列中的节点，存入答案，并把该节点的后续节点入度减一，得到新的有向图。</strong></p>
<h3 id="例题一-：-标准拓扑"><a href="#例题一-：-标准拓扑" class="headerlink" title="例题一 ： 标准拓扑"></a>例题一 ： 标准拓扑</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-ii/">课程表II</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">g</span>(numCourses);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">indgree</span>(numCourses,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;i:prerequisites)&#123;</span><br><span class="line">            g[i[<span class="number">1</span>]].<span class="built_in">push_back</span>(i[<span class="number">0</span>]);</span><br><span class="line">            indgree[i[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indgree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> i=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:g[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(--indgree[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">size</span>()==numCourses?ans:<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="例题二-：-拓扑-贪心"><a href="#例题二-：-拓扑-贪心" class="headerlink" title="例题二 ： 拓扑+贪心"></a>例题二 ： 拓扑+贪心</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-iii/">课程表III</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scheduleCourse</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; courses)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按ddl排序</span></span><br><span class="line">        <span class="built_in">sort</span>(courses.<span class="built_in">begin</span>(),courses.<span class="built_in">end</span>(),[](<span class="type">const</span> <span class="keyword">auto</span>&amp;a1,<span class="type">const</span> <span class="keyword">auto</span>&amp;a2)&#123;</span><br><span class="line">            <span class="keyword">return</span> a1[<span class="number">1</span>]&lt;a2[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">        <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; cour:courses)&#123;</span><br><span class="line">            <span class="type">int</span> ti=cour[<span class="number">0</span>],ddl=cour[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(total+ti&lt;=ddl)&#123;</span><br><span class="line">                <span class="comment">//可以加入,直接加</span></span><br><span class="line">                total+=ti;</span><br><span class="line">                q.<span class="built_in">push</span>(ti);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!q.<span class="built_in">empty</span>()&amp;&amp;q.<span class="built_in">top</span>()&gt;ti)&#123;</span><br><span class="line">                <span class="comment">//有安排的情况下，最后安排的事情耗时大于当前事件</span></span><br><span class="line">                total-=q.<span class="built_in">top</span>()-ti;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(ti);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="例题三-：-拓扑-搜索"><a href="#例题三-：-拓扑-搜索" class="headerlink" title="例题三 ： 拓扑 + 搜索"></a>例题三 ： 拓扑 + 搜索</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-iv/">课程表IV</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">checkIfPrerequisite</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">g</span>(numCourses);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">indgree</span>(numCourses,<span class="number">0</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt;<span class="built_in">isPre</span>(numCourses,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(numCourses,<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;p:prerequisites)&#123;</span><br><span class="line">            indgree[p[<span class="number">1</span>]]++;</span><br><span class="line">            g[p[<span class="number">0</span>]].<span class="built_in">push_back</span>(p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indgree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//cur的出口</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;out :g[cur])&#123;</span><br><span class="line">                isPre[cur][out]=<span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//父节点传递</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">                    isPre[i][out]=isPre[i][out] | isPre[i][cur];</span><br><span class="line">                &#125;</span><br><span class="line">                --indgree[out];</span><br><span class="line">                <span class="keyword">if</span>(indgree[out]==<span class="number">0</span>)q.<span class="built_in">push</span>(out);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt;ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;que:queries)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(isPre[que[<span class="number">0</span>]][que[<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2025 zhywyt
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>